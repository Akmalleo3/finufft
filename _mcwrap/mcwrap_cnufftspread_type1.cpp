/*
*
* This file was auto-generated by MCWRAP
* https://github.com/magland/mcwrap
*
* You should not edit this file.
* You might not even want to read it.
* 
*/ 

#include "mex.h"

#include "../cnufftspread.h"
#include "../cnufftspread.h"
#include "../besseli.h"

//====================================================================
//====================================================================
        
int mcwrap_size(const mxArray *X,int j);

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{

      //mexPrintf("test A\n");
//   Check the number of inputs/outputs
      if (nlhs==0) nlhs=1;
      if (nrhs!=6)
         mexErrMsgTxt("Incorrect number of inputs"); 
      else if (nlhs>1)
         mexErrMsgTxt ("Too many outputs.");

      // mexPrintf("test A.2\n");
//    Setup the set inputs
        //M
        int input_M=(int)(mcwrap_size(prhs[2-1],1));

      //mexPrintf("test B\n");
//    Setup the inputs
        //N
        double *p_input_N=mxGetPr(prhs[1-1]);
        int input_N=(int)p_input_N[0];
        //kx
        //Check that we have the correct dimensions!
        {
            int numdims=mxGetNumberOfDimensions(prhs[2-1]);
            if (numdims!=2) {
              mexErrMsgTxt("Incorrect number of dimensions in input: kx");
            }
            const mwSize *dims2=mxGetDimensions(prhs[2-1]);
            int dims[]={ input_M,1 };
            for (long ii=0; ii<numdims; ii++) {
              if (dims[ii]!=dims2[ii]) {
                mexErrMsgTxt("Incorrect size of input: kx");
              }
            }
        }
        double *input_kx=mxGetPr(prhs[2-1]);
        
        //ky
        //Check that we have the correct dimensions!
        {
            int numdims=mxGetNumberOfDimensions(prhs[3-1]);
            if (numdims!=2) {
              mexErrMsgTxt("Incorrect number of dimensions in input: ky");
            }
            const mwSize *dims2=mxGetDimensions(prhs[3-1]);
            int dims[]={ input_M,1 };
            for (long ii=0; ii<numdims; ii++) {
              if (dims[ii]!=dims2[ii]) {
                mexErrMsgTxt("Incorrect size of input: ky");
              }
            }
        }
        double *input_ky=mxGetPr(prhs[3-1]);
        
        //kz
        //Check that we have the correct dimensions!
        {
            int numdims=mxGetNumberOfDimensions(prhs[4-1]);
            if (numdims!=2) {
              mexErrMsgTxt("Incorrect number of dimensions in input: kz");
            }
            const mwSize *dims2=mxGetDimensions(prhs[4-1]);
            int dims[]={ input_M,1 };
            for (long ii=0; ii<numdims; ii++) {
              if (dims[ii]!=dims2[ii]) {
                mexErrMsgTxt("Incorrect size of input: kz");
              }
            }
        }
        double *input_kz=mxGetPr(prhs[4-1]);
        
        //X
        //Check that we have the correct dimensions!
        {
            int numdims=mxGetNumberOfDimensions(prhs[5-1]);
            if (numdims!=2) {
              mexErrMsgTxt("Incorrect number of dimensions in input: X");
            }
            const mwSize *dims2=mxGetDimensions(prhs[5-1]);
            int dims[]={ input_M,1 };
            for (long ii=0; ii<numdims; ii++) {
              if (dims[ii]!=dims2[ii]) {
                mexErrMsgTxt("Incorrect size of input: X");
              }
            }
        }
        double *input_X_re=mxGetPr(prhs[5-1]);
        double *input_X_im=mxGetPi(prhs[5-1]);
        double *input_X=(double *)malloc(sizeof(double)*((input_M)*(1)*2));
        for (long ii=0; ii<(input_M)*(1); ii++) {
            input_X[ii*2]=input_X_re[ii];
            if (input_X_im) {
                input_X[ii*2+1]=input_X_im[ii];
            }
            else {
                input_X[ii*2+1]=0;    
            }
        }
        //kernel_params
        //Check that we have the correct dimensions!
        {
            int numdims=mxGetNumberOfDimensions(prhs[6-1]);
            if (numdims!=2) {
              mexErrMsgTxt("Incorrect number of dimensions in input: kernel_params");
            }
            const mwSize *dims2=mxGetDimensions(prhs[6-1]);
            int dims[]={ 4,1 };
            for (long ii=0; ii<numdims; ii++) {
              if (dims[ii]!=dims2[ii]) {
                mexErrMsgTxt("Incorrect size of input: kernel_params");
              }
            }
        }
        double *input_kernel_params=mxGetPr(prhs[6-1]);
        
    
      //mexPrintf("test C\n");
//    Setup the outputs
        //Y
        double *output_Y_re;
        double *output_Y_im;
        double *output_Y;
        if (1<=nlhs) {
        if ((3<1)||(3>20)) {
          mexErrMsgTxt("Bad number of dimensions for my taste: 3"); 
        }
        {
            int dims2[]={ input_N,input_N,input_N };
            for (long ii=0; ii<3; ii++) {
                if ((dims2[ii]<1)||(dims2[ii]>10000000000.0)) {
                  mexErrMsgTxt ("Bad array size for my taste: input_N,input_N,input_N"); 
                }
            }
        }
        
            mwSize dims[]={ input_N,input_N,input_N };
            plhs[1-1]=mxCreateNumericArray(3,dims,mxDOUBLE_CLASS,mxCOMPLEX);
            output_Y_re=mxGetPr(plhs[1-1]);
            output_Y_im=mxGetPi(plhs[1-1]);
        }
        output_Y=(double *)malloc(sizeof(double)*((input_N)*(input_N)*(input_N))*2);

    
      //mexPrintf("test D\n");
//    Run the subroutine
        cnufftspread_type1(
        input_N,
        output_Y,
        input_M,
        input_kx,
        input_ky,
        input_kz,
        input_X,
        input_kernel_params

        );
   
      //mexPrintf("test E\n");
//    Free the inputs
        //kx
        //ky
        //kz
        //X
        free(input_X);
        //kernel_params

      //mexPrintf("test F\n");
//    Set the outputs
        //Y
        if (1<=nlhs) {
            for (long ii=0; ii<(input_N)*(input_N)*(input_N); ii++) {
                output_Y_re[ii]=output_Y[ii*2];
                output_Y_im[ii]=output_Y[ii*2+1];
            }
        }
        free(output_Y);

      //mexPrintf("test G\n");

/**** We are done *******/
}

int mcwrap_size(const mxArray *X,int j) {
    mwSize numdims=mxGetNumberOfDimensions(X);
    if ((j<1)||(j>numdims)) return 1;
    const mwSize *dims2=mxGetDimensions(X);
    return dims2[j-1];
}

        //$pname$
//CC Scalar output not yet supported!
